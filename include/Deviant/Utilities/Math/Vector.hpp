/*
    Deviant - SDL Game Library
    Copyright (C) 2015 Jack Riales (jack@thatnaughtypanda.com)

    This software is provided 'as-is', without any express or implied warranty.
    In no event will the authors be held liable for any damages arising from the use of this software.

    Permission is granted to anyone to use this software for any purpose,
    including commercial applications, and to alter it and redistribute it freely,
    subject to the following restrictions:

    1. The origin of this software must not be misrepresented;
    you must not claim that you wrote the original software.
    If you use this software in a product, an acknowledgment
    in the product documentation would be appreciated but is not required.

    2. Altered source versions must be plainly marked as such,
    and must not be misrepresented as being the original software.

    3. This notice may not be removed or altered from any source distribution.
*/

#ifndef DVNT_VECTOR_HPP
#define DVNT_VECTOR_HPP

#include <cmath>

namespace dv {

template<typename T = int>
struct Vector2D {
    /**
        Constructor
    */
    Vector2D(T _x = 0, T _y = 0);

    /**
        Copy constructor
    */
    Vector2D(const Vector2D& cpy);

    /**
        \return the magnitude of the vector.
        The magnitude is the length of the line generated by the two points.
    */
    const T magnitude() const;

    /**
        \return The vector in normalized (unit vector) form.
        The normalized vector will give a direction-only vector with values
        clamped between 0 and 1.
    */
    Vector2D<T> normalized() const;

    /**
        \return The dot product of the two vectors.
    */
    T dot(const Vector2D& v);

    /**
        Scale the vector by the given vector.

        \example
        Let V be a vector defined by the values (x = n) (y = m)
        Let G be a vector defined by the values (x = 0.5) (y = 0.5)
        Scaling V by G will generate the values (x = n / 2) (y = m / 2)
    */
    void scale(const Vector2D& v);

    /*
        Operator overloading
    */
    Vector2D& operator=(const Vector2D& v);
    Vector2D& operator=(const T& v);
    Vector2D& operator+(const Vector2D& v);
    Vector2D& operator+(const T& v);
    Vector2D& operator-(const Vector2D& v);
    Vector2D& operator-(const T& v);

    /*
        Shorthand methods for getting certain common vectors.
        zero() returns (0,0)
        one() returns (1,1)
        up() returns (0,1)
        right() returns (1,0)
        down() returns (0,-1)
        left() returns (-1,0)
    */
    static Vector2D zero()  { return *new Vector2D(0,0); }
    static Vector2D one()   { return *new Vector2D(1,1); }
    static Vector2D up()    { return *new Vector2D(0,1); }
    static Vector2D right() { return *new Vector2D(1,0); }
    static Vector2D down()  { return *new Vector2D(0,-1); }
    static Vector2D left()  { return *new Vector2D(-1,0); }

    // X and Y components
    T   x;
    T   y;
};

}

#endif // DVNT_VECTOR_HPP

// EOF Vector.hpp
// Location at: /include/Deviant/Math/Vector.hpp
